package problem70015

func hammingWeight1(num uint32) (count int) {
	for i := 0; i < 32; i++ {
		if 1 == ((num >> i) & 1) {
			count++
		}
	}
	return
}

func hammingWeight2(num uint32) (count int) {
	for ; 0 != num; num >>= 1 {
		count += int(num & 1)
	}
	return
}

func hammingWeight3(num uint32) (count int) {
	// num &= (num - 1) 为 每次去掉最右边一个 1
	// num 				xxxxx10000
	// num - 1			xxxxx01111
	// num & (num - 1)	xxxxx00000
	for ; num != 0; num &= (num - 1) {
		count++
	}
	return
}

func hammingWeight4(num uint32) (count int) {
	bitTable := [256]int{
		0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
		1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
		1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
		2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
		1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
		2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
		2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
		3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
		1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
		2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
		2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
		3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
		2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
		3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
		3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
		4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
	}
	return bitTable[num&0xff] + bitTable[(num>>8)&0xff] + bitTable[(num>>16)&0xff] + bitTable[(num>>24)&0xff]
}

func hammingWeight5(num uint32) (count int) {
	bitTable := [256]int{}
	// i = 0 也成立
	for i := range bitTable {
		// 递推式
		bitTable[i] = bitTable[i>>1] + i&1
	}
	return bitTable[num&0xff] + bitTable[(num>>8)&0xff] + bitTable[(num>>16)&0xff] + bitTable[(num>>24)&0xff]
}

// 每两位存储，使用加法（先移位再与运算）
func hammingWeight6(num uint32) int {
	// 以 11011110111001110111001100010101 为例子，这里分析下 （后续都差不多类似，不具体分析了）

	// 计算每 2 位的
	num = num&0x55555555 + (num>>1)&0x55555555
	// 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01		// 0x55555555
	// 11 01 11 10 11 10 01 11 01 11 00 11 00 01 01 01		// num
	// _1 _1 _1 _0 _1 _0 _1 _1 _1 _1 _0 _1 _0 _1 _1 _1		// num & 0x55555555
	//  1 _0 _1 _1 _1 _1 _0 _1 _0 _1 _0 _1 _0 _0 _0 _0|1	// (num>>1)&0x55555555
	// 10 01 11 01 10 01 01 10 01 10 00 10 00 01 01 01		// num&0x55555555 + (num>>1)&0x55555555
	//  2  1  2  1  2  1  1  2  1  1  0  1  0  1  1  1		// 每2位中1的个数

	// 计算每 4 位的
	num = num&0x33333333 + (num>>2)&0x33333333
	// 0011 0011 0011 0011 0011 0011 0011 0011				// 0x33333333
	// 1001 1011 1001 0110 0110 0010 0001 0101				// num
	// __01 __11 __01 __10 __10 __10 __01 __01				// num & 0x33333333
	//   10 __10 __10 __01 __01 __00 __00 __01|01			// (num>>2)&0x33333333
	// 0011 0011 0011 0011 0011 0010 0001 0010				// num&0x33333333 + (num>>2)&0x33333333
	//    3    3    3    3    3    2    1    2				// 每4位中1的个数

	// 计算每 8 位的
	num = num&0x0f0f0f0f + (num>>4)&0x0f0f0f0f
	// 00001111 00001111 00001111 00001111					// 0x0f0f0f0f
	// 00110011 00110011 00110010 00010010					// num
	// ____0011 ____0011 ____0010 ____0010					// num&0x0f0f0f0f
	//     0011 ____0011 ____0011 ____0001|0010				// (num>>4)&0x0f0f0f0f
	// 00000110 00000110 00000101 00000011					// num&0x33333333 + (num>>2)&0x33333333
	//        6        6        5        3					// 每8位中1的个数

	// 计算每 16 位的
	num = num&0x00ff00ff + (num>>8)&0x00ff00ff
	// 0000000011111111 0000000011111111					// 0x00ff00ff
	// 0000011000000110 0000010100000011					// num
	// ________00000110 ________00000011					// num&0x00ff00ff
	//     	   00000110 ________00000101|00000011			// (num>>8)&0x00ff00ff
	// 0000000000001100 0000000000001000					// num&0x00ff00ff + (num>>8)&0x00ff00ff
	//               12                8					// 每16位中1的个数

	// 计算每 32 位的
	num = num&0x0000ffff + (num>>16)&0x0000ffff
	// 00000000000000001111111111111111						// 0x0000ffff
	// 00000000000011000000000000001000						// num
	// ________________0000000000001000						// num&0x00ff00ff
	//                 0000000000001100|0000000000001000	// (num>>16)&0x00ff00ff
	// 00000000000000000000000000010100						// num&0x0000ffff + (num>>16)&0x0000ffff
	//                               20						// 每16位中1的个数

	return int(num)
}

// 每两位存储，使用加法（先与运算再移位）
func hammingWeight7(num uint32) int {
	// 原理和上面的一样，只是这里先与运算再移位
	num = num&0x55555555 + (num&0xaaaaaaaa)>>1
	num = num&0x33333333 + (num&0xcccccccc)>>2
	num = num&0x0f0f0f0f + (num&0xf0f0f0f0)>>4
	num = num&0x00ff00ff + (num&0xff00ff00)>>8
	num = num&0x0000ffff + (num&0xffff0000)>>16
	return int(num)
}

func hammingWeight8(num uint32) int {
	// 原理和 hammingWeight6 一样，只是这里先与运算再移位
	num = num&0x55555555 + (num>>1)&0x55555555
	num = num&0x33333333 + (num>>2)&0x33333333
	num = num&0x0f0f0f0f + (num>>4)&0x0f0f0f0f
	num = num + num>>8
	num = num + num>>16
	// 因为上面两行没有进行与运算，所以前面的数据都是无效的，只有最后8位是有效的，
	// 而后8位的前两位不用说肯定为0，因为最多也就32个1，用后面6位数表示就已经足够了
	return int(num & 0x3f) //0x3f 0011 1111
}

func hammingWeight9(num uint32) int {
	// 只需要用这两位数减去偶数位上的值，例如：
	// 00 - 0 = 00 	表示有0个1
	// 01 - 0 = 01 	表示有1个1
	// 10 - 1 = 01 	表示有1个1
	// 11 - 1 = 10 	表示有2个1
	// 设第一位为 a 第二位 为 b ，则 num = 2a + b ，num>>1 = a
	// num - (num>>1) = a+b 也就是位数，&0x55555555 是消除 num>>1 对应的没两位中的高位
	num = num - (num>>1)&0x55555555
	num = num&0x33333333 + (num>>2)&0x33333333
	num = num&0x0f0f0f0f + (num>>4)&0x0f0f0f0f
	num = num&0x00ff00ff + (num&0xff00ff00)>>8
	num = num&0x0000ffff + (num&0xffff0000)>>16
	return int(num)
}

func hammingWeight10(num uint32) int {
	num = num&0x55555555 + (num>>1)&0x55555555
	num = num&0x33333333 + (num>>2)&0x33333333
	num = num&0x0f0f0f0f + (num>>4)&0x0f0f0f0f
	// 第三步的结果是每8位分割的
	// num 为 00000110 00000110 00000101 00000011
	// ------------溢出----------|--保留--|-----------删除------------
	//                           |00000110 00000110 00000101 00000011 // num * 0x00000001
	//                   00000110|00000110 00000101 00000011          // num * 0x00000100
	//          00000110 00000110|00000101 00000011                   // num * 0x00010000
	// 00000110 00000110 00000101|00000011                            // num * 0x01000000
	//+                           00010100 -> 20
	num = (num * 0x01010101) >> 24
	return int(num)
}

func hammingWeight11(num uint32) int {
	num -= (num >> 1) & 0x55555555
	num = num&0x33333333 + (num>>2)&0x33333333
	num = num&0x0f0f0f0f + (num>>4)&0x0f0f0f0f
	num += num >> 8
	num += num >> 16
	return int(num & 0x3f)
}

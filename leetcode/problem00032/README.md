# [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

## 题目

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:

```c
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

示例 2:

```c
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

## 解题思路

### 动态规划

dp[i] 表示以下标 i 字符结尾的最长有效括号的长度。以 '(' 结尾的子串对应的 dp 值必定为 0 。

只有 dp[i] == ')' 的时候，才会有值

```go
// 1. 如果 dp[i-1] = '(' ，也就是类似 "..................()"，则 dp[i] = dp[i-1] + 2
// 2. 如果 s[i-1] = ')' ，也就是类似 "..................))" 这种的，则：
//     只有当 dp[i-1] 为有效的括号对( dp[i-1] > 0 )的时候，dp[i] 才可能为有效的，类似 "......(...........))"
//     只有当 s[i-1] = ')' 对应的位置(i - 1 - dp[i-1] + 1)必定为 '('
//     并且只有当对应位置前面一个( i - 1 - dp[i-1] + 1 - 1 )也为 '(' ，s[i] 才为有效的括号对
//     即： dp[i-1] > 0 && s[i - dp[i-1] - 1] == '(' 时候
//     又由于 i - 1 - dp[i-1] + 1 - 1 之前可能也有有效的括号对，所以还需要加上，最终为：
//     dp[i] = dp[i - dp[i - 1] - 2] + dp[i - 1] + 2
```

### 栈

```go
// 始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」
// 初始化入栈 -1
// 1. 如果是 '(' ，入栈
// 2. 否则，出栈
//     2.1 如果栈空了，说明当前的右括号为没有被匹配的右括号，则入栈
//     2.2 果栈不为空，则计算

```

### 双向计数对比

两个计数器 left 和 right 分别表示左右括号的数目。

从前往后找：

* 当 left == right 时候表示匹配了。
* 当 right > left 的时候，此时肯定已经不为最长有效括号对了，并且已经措施良机，left,right 清零。

当左括号比右括号多，比如 "(()" ，就无法算出，因此再反向从后往前计算一遍：

* 当 left == right 时候表示匹配了。
* 当 left > right 的时候，此时肯定已经不为最长有效括号对了，并且已经措施良机，left,right 清零。

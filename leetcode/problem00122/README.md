# [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

## 题目

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

```c
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

示例 2:

```c
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

示例 3:

```c
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

提示：

* 1 <= prices.length <= 3 * 10 ^ 4
* 0 <= prices[i] <= 10 ^ 4

## 解题思路

### 普通方法

先找一个最低价格买入，再找一个最高价格卖掉

### 贪心法

看作是前一天买入，第二天就卖掉，虽然不能模拟真实的买卖情况，但是最终收益一样

### DP算法

定义状态:

* `dp[i][0]` 表示第 `i` 天交易完后手里没有股票的最大利润
* `dp[i][1]` 表示第 `i` 天交易完后手里持有一支股票的最大利润

初始状态：

* dp[0][0] = 0
* dp[0][1] = -prices[0]

转移方程：

* dp[i][0]=max(dp[i−1][0],dp[i−1][1]+prices[i])
* dp[i][1]=max(dp[i−1][1],dp[i−1][0]−prices[i])

### DP算法（空间优化）

上面状态方程中，dp[i][0]，dp[i][1] 只是 依赖 dp[i−1][0] 和 dp[i−1][1]

定义状态:

* `dp0` 表示第 `i` 天交易完后手里没有股票的最大利润
* `dp1` 表示第 `i` 天交易完后手里持有一支股票的最大利润

初始状态：

* dp0 = 0
* dp1 = -prices[0]

转移方程：

* dp0=max(dp0,dp1+prices[i])
* dp1=max(dp1,dp0−prices[i])

### 单调栈

单调栈的作用是：用 O(n) 的时间得知所有位置两边第一个比他大(或小)的数的位置。

# [659. 分割数组为连续子序列](https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/)

## 题目

给你一个按升序排序的整数数组 num（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。

如果可以完成上述分割，则返回 true ；否则，返回 false 。

示例 1:

```c
输入: [1,2,3,3,4,5]
输出: True
解释:
你可以分割出这样两个连续子序列 :
1, 2, 3
3, 4, 5
```

示例 2:

```c
输入: [1,2,3,3,4,4,5,5]
输出: True
解释:
你可以分割出这样两个连续子序列 :
1, 2, 3, 4, 5
3, 4, 5
```

示例 3:

```c
输入: [1,2,3,4,4,5]
输出: False
```

提示:

* 输入的数组长度范围为 [1, 10000]

## 解题思路

### 最小堆

维护以每个数字为子序列最后一个数的最小堆

如果有前一个数字，则 Pop 出来，将当前数加在后面，组成新的组序列，长度比之前的多 1

如果没有，则重新组成一个，其长度为 1

最后判断所有最小堆都 > 3

### 从小到大取数字

用 2 个 map 分别统计每个数字个个数和以每个数字为一个数的子序列个数

如果前一个有，则加到前一个上面

否则需要重新组成，拿向后连续 2 个一起组成新的子序列

如果找不到，则不满足

### 统计相同元素个数

len1Count, len2Count, len3Count 分别为子序列长度为 1,2 >=3 的个数

相同元素的个数为 count

如果是第 1 个数及其相同的，则设置 len1Count 即可

如果中断了，如果还有长度为 1 或者 2 的子序列，则不满足，否则 len1Count = count, len2Count = 0, len3Count = 0

如果未中断，count 个数，优先拼接短的， 先 len1Count ，在 len2Count ，最后再 len3Count (加长原有的链)， 如果 len3Count 分不完，则多的重新组成新长度为 1 的子序列，也就是给 len1Count
